# 常用算法

## 选择排序

选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)

算法规则： 将待排序集合(0...n)看成两部分，在起始状态中，一部分为(k..n)的待排序unsorted集合，另一部分为(0...k)的已排序sorted集合,在待排序集合中挑选出最小元素并且记录下标i，若该下标不等于k，那么 unsorted[i] 与 sorted[k]交换 ，一直重复这个过程，直到unsorted集合中元素为空为止。


```
public class SelectSort {

public static void selectSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    int minIndex = 0;
    for(int i=0; i&lt;arr.length-1; i++) { //只需要比较n-1次
        minIndex = i;
        for(int j=i+1; j&lt;arr.length; j++) { //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。
            if(arr[j] &lt; arr[minIndex]) {
                minIndex = j;
            }
        }

        if(minIndex != i) { //如果minIndex不为i，说明找到了更小的值，交换之。
            swap(arr, i, minIndex);
        }
    }

}

public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}


}
```

## 冒泡排序

冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。

实现代码：

```
public class BubbleSort {

public static void bubbleSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    for(int i=0; i&lt;arr.length-1; i++) {
        for(int j=arr.length-1; j&gt;i; j--) {
            if(arr[j] &lt; arr[j-1]) {
                swap(arr, j-1, j);
            }
        }
    }
}

public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}


}
```

## 快速排序

冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。

5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。

5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。

5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。

4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。

上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。

快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。

本质来说，快速排序的过程就是不断地将无序元素集递归分割，一直到所有的分区只包含一个元素为止。
由于快速排序是一种分治算法，我们可以用分治思想将快排分为三个步骤：

1. 分：设定一个分割值，并根据它将数据分为两部分
2. 治：分别在两部分用递归的方式，继续使用快速排序法
3. 合：对分割的部分排序直到完成

> 冒泡+二分+递归分治

```
public class QuickSort {
    //一次划分
    public static int partition(int[] arr, int left, int right) {
        int pivotKey = arr[left];
        int pivotPointer = left;

    while(left &lt; right) {
        while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)
            right --;
        while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)
            left ++;
        swap(arr, left, right); //把大的交换到右边，把小的交换到左边。
    }
    swap(arr, pivotPointer, left); //最后把pivot交换到中间
    return left;
}

public static void quickSort(int[] arr, int left, int right) {
    if(left &gt;= right)
        return ;
    int pivotPos = partition(arr, left, right);
    quickSort(arr, left, pivotPos-1);
    quickSort(arr, pivotPos+1, right);
}

public static void sort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    quickSort(arr, 0, arr.length-1);
}

public static void swap(int[] arr, int left, int right) {
    int temp = arr[left];
    arr[left] = arr[right];
    arr[right] = temp;
}


}
```

其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下：

```
public class QuickSort {

/**
 * 划分
 * @param arr
 * @param left
 * @param right
 * @return
 */
public static int partition(int[] arr, int left, int right) {
    int pivotKey = arr[left];

    while(left &lt; right) {
        while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)
            right --;
        arr[left] = arr[right]; //把小的移动到左边
        while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)
            left ++;
        arr[right] = arr[left]; //把大的移动到右边
    }
    arr[left] = pivotKey; //最后把pivot赋值到中间
    return left;
}

/**
 * 递归划分子序列
 * @param arr
 * @param left
 * @param right
 */
public static void quickSort(int[] arr, int left, int right) {
    if(left &gt;= right)
        return ;
    int pivotPos = partition(arr, left, right);
    quickSort(arr, left, pivotPos-1);
    quickSort(arr, pivotPos+1, right);
}

public static void sort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    quickSort(arr, 0, arr.length-1);
}


}
```

## 插入排序

插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。

实现代码：

```
public class InsertSort {

public static void insertSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;

    for(int i=1; i&lt;arr.length; i++) { //假设第一个数位置时正确的；要往后移，必须要假设第一个。

        int j = i;
        int target = arr[i]; //待插入的

        //后移
        while(j &gt; 0 &amp;&amp; target &lt; arr[j-1]) {
            arr[j] = arr[j-1];
            j --;
        }

        //插入 
        arr[j] = target;
    }

	}
}
```

## 堆排序

堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。

首先，实现堆排序需要解决两个问题：

1. 如何由一个无序序列键成一个堆？

2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？

第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。

第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。

从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：

49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下：

![](https://camo.githubusercontent.com/1c7631b5c12ac1e45ebc2e90f3080880ffb6d7c6/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f32363134626365313139323633656463663964313862363336356233393139372e706e67)

![](https://camo.githubusercontent.com/40a3a702c3429b95d119d1118626fd17617db88a/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f61643337336135383931383264643162376534343339313563383737356663642e706e67)

```
public class HeapSort {

/**
 * 堆筛选，除了start之外，start~end均满足大顶堆的定义。
 * 调整之后start~end称为一个大顶堆。
 * @param arr 待调整数组
 * @param start 起始指针
 * @param end 结束指针
 */
public static void heapAdjust(int[] arr, int start, int end) {
    int temp = arr[start];

    for(int i=2*start+1; i&lt;=end; i*=2) {
        //左右孩子的节点分别为2*i+1,2*i+2

        //选择出左右孩子较小的下标
        if(i &lt; end &amp;&amp; arr[i] &lt; arr[i+1]) {
            i ++; 
        }
        if(temp &gt;= arr[i]) {
            break; //已经为大顶堆，=保持稳定性。
        }
        arr[start] = arr[i]; //将子节点上移
        start = i; //下一轮筛选
    }

    arr[start] = temp; //插入正确的位置
}

public static void heapSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;

    //建立大顶堆
    for(int i=arr.length/2; i&gt;=0; i--) {
        heapAdjust(arr, i, arr.length-1);
    }

    for(int i=arr.length-1; i&gt;=0; i--) {
        swap(arr, 0, i);
        heapAdjust(arr, 0, i-1);
    }

}

public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}


}
```

## 希尔排序

希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。

![](https://camo.githubusercontent.com/bad891f3cd2c6aa3781eefeeeb6a3b86b40d1423/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f61656630336230643233333962653334363237626364383161333830396536322e706e67)

从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。

希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。

```
public class ShellSort {

/**
 * 希尔排序的一趟插入
 * @param arr 待排数组
 * @param d 增量
 */
public static void shellInsert(int[] arr, int d) {
    for(int i=d; i&lt;arr.length; i++) {
        int j = i - d;
        int temp = arr[i];    //记录要插入的数据  
        while (j&gt;=0 &amp;&amp; arr[j]&gt;temp) {  //从后向前，找到比其小的数的位置   
            arr[j+d] = arr[j];    //向后挪动  
            j -= d;  
        }  

        if (j != i - d)    //存在比其小的数 
            arr[j+d] = temp;

    }
}

public static void shellSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;
    int d = arr.length / 2;
    while(d &gt;= 1) {
        shellInsert(arr, d);
        d /= 2;
    }
}


}
```

## 归并排序

归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。

- 算法规则： 像快速排序一样，由于归并排序也是分治算法，因此可使用分治思想：
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

![](https://camo.githubusercontent.com/29cee6111676d88550fc6c9671c558d77731a691/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f64663834373833363264396234323931336530323265666639346434336562342e706e67)



```
public void mergeSort(int[] ints, int[] merge, int start, int end) 
{
if (start >= end) return;
  	
int mid = (end + start) >> 1;
  	
mergeSort(ints, merge, start, mid);
mergeSort(ints, merge, mid + 1, end);

merge(ints, merge, start, end, mid);

}
  
private void merge(int[] a, int[] merge, int start, int end,int mid) 
{
int i = start;
int j = mid+1;
int pos = start;
while( i <= mid || j <= end ){
	if( i > mid ){
		while( j <= end ) merge[pos++] = a[j++];
		break;
	}
	
	if( j > end ){
		while( i <= mid ) merge[pos++] = a[i++];
		break;
	}
	
	merge[pos++] = a[i] >= a[j] ? a[j++] : a[i++];
}
  	
for (pos = start; pos <= end; pos++)
	a[pos] = merge[pos];
  
}

```

## 计数排序

用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。

```
public class CountSort {

public static void countSort(int[] arr) {
    if(arr == null || arr.length == 0)
        return ;

    int max = max(arr);

    int[] count = new int[max+1];
    Arrays.fill(count, 0);

    for(int i=0; i&lt;arr.length; i++) {
        count[arr[i]] ++;
    }

    int k = 0;
    for(int i=0; i&lt;=max; i++) {
        for(int j=0; j&lt;count[i]; j++) {
            arr[k++] = i;
        }
    }

}

public static int max(int[] arr) {
    int max = Integer.MIN_VALUE;
    for(int ele : arr) {
        if(ele &gt; max)
            max = ele;
    }

    return max;
}


}
```


## 桶排序

桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。

假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1<k2，那么f(k1)<=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。

![](https://camo.githubusercontent.com/ca1a5a10c6251d0ab2320b586cc458cc0135df49/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f34376263663433353935306636346338343863653433643561653531343261612e676966)

假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。

桶排序分析：

桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。

对N个关键字进行桶排序的时间复杂度分为两个部分：

(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。

(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。

很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：

(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。

(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。

对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：

O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)

当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。

总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。

```
public class BucketSort {

public static void bucketSort(int[] arr) {
    if(arr == null &amp;&amp; arr.length == 0)
        return ;

    int bucketNums = 10; //这里默认为10，规定待排数[0,100)
    List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //桶的索引

    for(int i=0; i&lt;10; i++) {
        buckets.add(new LinkedList&lt;Integer&gt;()); //用链表比较合适
    }

    //划分桶
    for(int i=0; i&lt;arr.length; i++) {
        buckets.get(f(arr[i])).add(arr[i]);
    }

    //对每个桶进行排序
    for(int i=0; i&lt;buckets.size(); i++) {
        if(!buckets.get(i).isEmpty()) {
            Collections.sort(buckets.get(i)); //对每个桶进行快排
        }
    }

    //还原排好序的数组
    int k = 0;
    for(List&lt;Integer&gt; bucket : buckets) {
        for(int ele : bucket) {
            arr[k++] = ele;
        }
    }
}

/**
 * 映射函数
 * @param x
 * @return
 */
public static int f(int x) {
    return x / 10;
}


}
```


## 基数排序


基数排序又是一种和前面排序方式不同的排序方式，基数排序不需要进行记录关键字之间的比较。基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。


![](https://camo.githubusercontent.com/a9fd86d9fcf8da0b1957eaec7819a3f2a3b4dc80/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f63623536666634306231616465376535376435616139383430666331656261332e706e67)

![](https://camo.githubusercontent.com/2a60056f3af10d90e551f24bc70f937a7d36ef6a/687474703a2f2f7374617469632e636f646563656f2e636f6d2f696d616765732f323031362f30332f37356433386363653233333336653133336464386561633333656162663561642e706e67)

```
public class RadixSort {

public static void radixSort(int[] arr) {
    if(arr == null &amp;&amp; arr.length == 0)
        return ;

    int maxBit = getMaxBit(arr);

    for(int i=1; i&lt;=maxBit; i++) {

        List&lt;List&lt;Integer&gt;&gt; buf = distribute(arr, i); //分配
        collecte(arr, buf); //收集
    }

}

/**
 * 分配
 * @param arr 待分配数组
 * @param iBit 要分配第几位
 * @return
 */
public static List&lt;List&lt;Integer&gt;&gt; distribute(int[] arr, int iBit) {
    List&lt;List&lt;Integer&gt;&gt; buf = new ArrayList&lt;List&lt;Integer&gt;&gt;();
    for(int j=0; j&lt;10; j++) {
        buf.add(new LinkedList&lt;Integer&gt;());
    }
    for(int i=0; i&lt;arr.length; i++) {
        buf.get(getNBit(arr[i], iBit)).add(arr[i]);
    }
    return buf;
}

/**
 * 收集
 * @param arr 把分配的数据收集到arr中
 * @param buf 
 */
public static void collecte(int[] arr, List&lt;List&lt;Integer&gt;&gt; buf) {
    int k = 0;
    for(List&lt;Integer&gt; bucket : buf) {
        for(int ele : bucket) {
            arr[k++] = ele;
        }
    }

}

/**
 * 获取最大位数
 * @param x
 * @return
 */
public static int getMaxBit(int[] arr) {
    int max = Integer.MIN_VALUE;
    for(int ele : arr) {
        int len = (ele+"").length();
        if(len &gt; max)
            max = len;
    }
    return max;
}

/**
 * 获取x的第n位，如果没有则为0.
 * @param x
 * @param n
 * @return
 */
public static int getNBit(int x, int n) {

    String sx = x + "";
    if(sx.length() &lt; n)
        return 0;
    else
        return sx.charAt(sx.length()-n) - '0';
}


}
```


> 参考《数据结构》
